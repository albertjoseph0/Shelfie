# Converting Express Routes to Serverless Functions for Vercel

Let's focus on converting your Express routes to Vercel serverless functions. This is a critical first step that allows your API to work in Vercel's environment while maintaining your current structure.

## 1. Create API Directory Structure

First, create a new `/api` directory at the root of your project:

```
/shelfie
├── /api                  # New API functions directory
├── /client               # Your existing client code
├── /server               # Your existing server code
```

## 2. Create Base Serverless Handler

Let's start by creating a basic serverless handler that will adapt your Express routes:

```javascript
// api/index.js
import express from 'express';
import serverless from 'serverless-http';
import { extractUserId, requireAuth, ensureUserId } from '../server/middleware/auth';
import { storage } from '../server/storage';
import { analyzeBookshelfImage } from '../server/services/openai';
import { searchBook, getBookById } from '../server/services/google-books';
import { nanoid } from 'nanoid';

// Create Express app
const app = express();
app.use(express.json({ limit: '50mb' }));
app.use(express.urlencoded({ extended: false, limit: '50mb' }));

// Add authentication middleware
app.use(extractUserId);

// Health check endpoint
app.get('/api/health', (_req, res) => {
  res.json({ status: 'ok' });
});

// Add your existing routes
// Books endpoint
app.get('/api/books', requireAuth, ensureUserId, async (req, res) => {
  try {
    const books = await storage.getBooks(req.userId);
    books.sort((a, b) => {
      return new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime();
    });
    res.json(books);
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
});

// Export endpoint
app.get('/api/export', requireAuth, ensureUserId, async (req, res) => {
  try {
    const books = await storage.getBooks(req.userId);
    
    // Create CSV header
    const csvRows = [
      [
        "Title",
        "Author",
        "ISBN",
        "Added Date",
        "Publisher",
        "Published Date",
        "Categories",
        "Page Count",
        "Description"
      ].join(",")
    ];

    // Add book data
    for (const book of books) {
      const row = [
        `"${book.title.replace(/"/g, '""')}"`,
        `"${book.author.replace(/"/g, '""')}"`,
        `"${book.isbn || ''}"`,
        `"${new Date(book.createdAt).toLocaleDateString()}"`,
        `"${book.metadata?.publisher || ''}"`,
        `"${book.metadata?.publishedDate || ''}"`,
        `"${book.metadata?.categories?.join('; ') || ''}"`,
        `"${book.pageCount || ''}"`,
        `"${(book.description || '').replace(/"/g, '""')}"`
      ].join(",");
      csvRows.push(row);
    }

    res.setHeader('Content-Type', 'text/csv');
    res.setHeader('Content-Disposition', 'attachment; filename=my-library.csv');
    res.send(csvRows.join("\n"));
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
});

// Analyze endpoint
app.post('/api/analyze', requireAuth, ensureUserId, async (req, res) => {
  try {
    const { image } = req.body;
    if (!image) {
      return res.status(400).json({ message: "Image data is required" });
    }

    const uploadId = nanoid();
    const analysis = await analyzeBookshelfImage(image);
    
    // Process books
    const books = await Promise.all(
      analysis.books.map(async (book) => {
        const googleBooks = await searchBook(`${book.title} ${book.author || ''}`);
        if (googleBooks.length === 0) return null;

        const bookInfo = googleBooks[0].volumeInfo;
        const bookData = {
          title: bookInfo.title,
          author: bookInfo.authors?.[0] || "Unknown",
          isbn: bookInfo.industryIdentifiers?.[0]?.identifier,
          coverUrl: bookInfo.imageLinks?.thumbnail,
          description: bookInfo.description,
          pageCount: bookInfo.pageCount,
          googleBooksId: googleBooks[0].id,
          createdAt: new Date().toISOString(),
          metadata: {
            categories: bookInfo.categories,
            publishedDate: bookInfo.publishedDate,
            publisher: bookInfo.publisher
          }
        };

        // Save the book
        const savedBook = await storage.createBook(bookData, uploadId, req.userId);
        return savedBook;
      })
    );

    const validBooks = books.filter(Boolean);
    res.json({ books: validBooks, uploadId });
  } catch (error) {
    console.error("Error in /api/analyze:", error);
    res.status(500).json({ message: error.message });
  }
});

// Delete book endpoint
app.delete('/api/books/:id', requireAuth, ensureUserId, async (req, res) => {
  try {
    const bookId = parseInt(req.params.id);
    await storage.deleteBook(bookId, req.userId);
    res.status(204).send();
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
});

// Undo upload endpoint
app.delete('/api/uploads/:uploadId', requireAuth, ensureUserId, async (req, res) => {
  try {
    const { uploadId } = req.params;
    await storage.deleteBooksByUploadId(uploadId, req.userId);
    res.status(204).send();
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
});

// Book details endpoint
app.get('/api/books/:id/details', requireAuth, ensureUserId, async (req, res) => {
  try {
    const book = await storage.getBook(parseInt(req.params.id), req.userId);
    if (!book?.googleBooksId) {
      return res.status(404).json({ message: "Book not found" });
    }

    const details = await getBookById(book.googleBooksId);
    res.json(details);
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
});

// Export the serverless handler
export default serverless(app);
```

## 3. Modularize Routes (Optional but Recommended)

For better organization, you can split routes into separate files:

```javascript
// api/books.js
import express from 'express';
import { requireAuth, ensureUserId } from '../server/middleware/auth';
import { storage } from '../server/storage';

const router = express.Router();

// Get all books
router.get('/', requireAuth, ensureUserId, async (req, res) => {
  try {
    const books = await storage.getBooks(req.userId);
    books.sort((a, b) => {
      return new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime();
    });
    res.json(books);
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
});

// Get book details
router.get('/:id/details', requireAuth, ensureUserId, async (req, res) => {
  try {
    const book = await storage.getBook(parseInt(req.params.id), req.userId);
    if (!book?.googleBooksId) {
      return res.status(404).json({ message: "Book not found" });
    }

    const details = await getBookById(book.googleBooksId);
    res.json(details);
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
});

// Delete book
router.delete('/:id', requireAuth, ensureUserId, async (req, res) => {
  try {
    const bookId = parseInt(req.params.id);
    await storage.deleteBook(bookId, req.userId);
    res.status(204).send();
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
});

export default router;
```

Then update your main index.js:

```javascript
// api/index.js
import express from 'express';
import serverless from 'serverless-http';
import { extractUserId } from '../server/middleware/auth';
import booksRouter from './books';
import analyzeRouter from './analyze';
import exportsRouter from './export';

const app = express();
app.use(express.json({ limit: '50mb' }));
app.use(express.urlencoded({ extended: false, limit: '50mb' }));

// Add authentication middleware
app.use(extractUserId);

// Health check endpoint
app.get('/api/health', (_req, res) => {
  res.json({ status: 'ok' });
});

// Mount routers
app.use('/api/books', booksRouter);
app.use('/api/analyze', analyzeRouter);
app.use('/api/export', exportsRouter);

// Export the serverless handler
export default serverless(app);
```

## 4. Create Individual Serverless Functions (Alternative Approach)

Vercel also supports individual serverless functions. This approach can be simpler for smaller applications:

```javascript
// api/books.js
import { requireAuth, ensureUserId } from '../server/middleware/auth';
import { storage } from '../server/storage';

export default async function handler(req, res) {
  // Apply authentication middleware
  try {
    await new Promise((resolve, reject) => {
      requireAuth(req, res, (err) => {
        if (err) reject(err);
        else resolve();
      });
    });
    
    await new Promise((resolve, reject) => {
      ensureUserId(req, res, (err) => {
        if (err) reject(err);
        else resolve();
      });
    });
  } catch (error) {
    return res.status(401).json({ message: "Unauthorized" });
  }

  // Handle different HTTP methods
  if (req.method === 'GET') {
    // Get all books or a specific book
    try {
      const bookId = req.query.id;
      
      if (bookId) {
        const book = await storage.getBook(parseInt(bookId), req.userId);
        if (!book) {
          return res.status(404).json({ message: "Book not found" });
        }
        return res.json(book);
      } else {
        const books = await storage.getBooks(req.userId);
        books.sort((a, b) => {
          return new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime();
        });
        return res.json(books);
      }
    } catch (error) {
      return res.status(500).json({ message: error.message });
    }
  } 
  else if (req.method === 'DELETE') {
    try {
      const bookId = parseInt(req.query.id);
      await storage.deleteBook(bookId, req.userId);
      return res.status(204).send();
    } catch (error) {
      return res.status(500).json({ message: error.message });
    }
  }
  
  // Method not allowed
  return res.status(405).json({ message: "Method not allowed" });
}
```

## 5. Update Authentication Middleware

The Clerk middleware might need some adjustments for Vercel's serverless environment:

```javascript
// api/_middleware/auth.js
import { ClerkExpressRequireAuth, ClerkExpressWithAuth } from '@clerk/clerk-sdk-node';

// Middleware that doesn't end the request on failure (for error handling)
export const extractUserId = (req, res, next) => {
  ClerkExpressWithAuth({
    jwtKey: process.env.CLERK_JWT_KEY,
    secretKey: process.env.CLERK_SECRET_KEY,
  })(req, res, next);
};

// Middleware that requires auth
export const requireAuth = (req, res, next) => {
  ClerkExpressRequireAuth({
    jwtKey: process.env.CLERK_JWT_KEY,
    secretKey: process.env.CLERK_SECRET_KEY,
  })(req, res, next);
};

// Helper to ensure userId exists and format it
export const ensureUserId = (req, res, next) => {
  const clerkUserId = req.auth?.userId;
  
  if (!clerkUserId) {
    return res.status(401).json({ message: "Unauthorized" });
  }
  
  req.userId = clerkUserId;
  next();
};
```

## 6. Create a Vercel Configuration File

Create a `vercel.json` file in your project root:

```json
{
  "version": 2,
  "builds": [
    {
      "src": "api/index.js",
      "use": "@vercel/node"
    }
  ],
  "routes": [
    {
      "src": "/api/(.*)",
      "dest": "/api/index.js"
    }
  ]
}
```

## 7. Install Required Dependencies

```bash
npm install serverless-http @vercel/node --save
```

## 8. Important Notes About Function Structure

1. **Path Prefixes**: Note that in the Express app, we're using `/api/books` but when deployed to Vercel, the `/api` prefix is typically implicit in the URL structure.

2. **Environment Variables**: Make sure to set up your environment variables in the Vercel dashboard.

3. **Memory Storage Issues**: Your current implementation uses in-memory storage (`MemStorage`), which won't work properly in a serverless environment because:
   - Functions are stateless and don't maintain memory between executions
   - Multiple function instances might be running simultaneously

   However, as you requested, we're not changing that part yet - we'll address the database migration in a subsequent step.

## 9. Testing Locally

Before deploying to Vercel, you can test your serverless functions locally:

```bash
# Install Vercel CLI
npm install -g vercel

# Run local development server
vercel dev
```

This wraps up the Express routes to serverless functions conversion. In the next step, we'll address replacing the in-memory storage with a persistent database solution. Would you like to proceed with that next?​​​​​​​​​​​​​​​​